\documentclass[a4paper,10pt,twoside]{report}
\usepackage[a4paper]{geometry}
\usepackage{listings}
\usepackage[x-iso-8859-1]{inputenc} % ISO 8859-1
\usepackage[ngerman]{babel}
\usepackage{color}
\usepackage[pdftex]{graphicx}
\usepackage{fancyhdr}
\usepackage{amsmath,amssymb,amsfonts,textcomp}
\usepackage{hyperref}
\usepackage[compact]{titlesec} % KapitelÜberschriften
\usepackage[T1]{fontenc}
\usepackage{xspace}


\usepackage{listings}
 \lstset{
   basicstyle=\scriptsize\ttfamily,
   keywordstyle=\bfseries\ttfamily\color{orange},
   stringstyle=\color{green}\ttfamily,
   commentstyle=\color{middlegray}\ttfamily,
   emph={square}, 
   emphstyle=\color{blue}\texttt,
   emph={[2]root,base},
   emphstyle={[2]\color{yac}\texttt},
   showstringspaces=false,
   flexiblecolumns=true,
   tabsize=2,
   numbers=left,
   numberstyle=\tiny,
   numberblanklines=false,
   stepnumber=1,
   numbersep=10pt,
   xleftmargin=1 pt
 }

% Dateipfade
\graphicspath{{pictures/}}

% Eigene Farben
\definecolor{lightgray}{rgb}{0.95,0.95,0.95}
\definecolor{codegray}{rgb}{0.8,0.8,0.8}
\definecolor{darkgray}{rgb}{0.18,0.18,0.18}
\definecolor{mygreen}{rgb}{0.133,0.545,0.133}
\definecolor{mypurple}{rgb}{0.627,0.126,0.941}

% PDF Informationen
\title{Beispieldokumentation zum Projektpraktikum}
\author{Hier bitte Autor eintragen}

% Seitengestaltung
\setlength\textheight{25.0cm}
\setlength\topmargin{-1.3cm}
\setlength\textwidth{1.1\textwidth}
% ohne Heftkante
\setlength\oddsidemargin{0pt}
\setlength\evensidemargin{0pt}
% mit Heftkante
%\setlength\oddsidemargin{+10pt}
%\setlength\evensidemargin{-10pt}
\setlength{\headheight}{13pt}

% Kopf- und FuÃzeilen
\pagestyle{fancy}
\fancypagestyle{plain}{\thispagestyle{fancy}}

\fancyhead{}
%\fancyheadoffset[LE,RO]{0pt}
\fancyhead[LO,RE]{\rightmark} % aktuelle Section
\fancyhead[RO,LE]{\includegraphics[viewport=0 7.5 168 24,scale=0.5]{header}} % Logo here

\fancyfoot{}
%\fancyfootoffset[LE,RO]{0pt}
\fancyfoot[LO,RE]{\leftmark} % aktuelle Chapter
\fancyfoot[LE]{\thepage\hspace{3em}Dokumentation zum IT-Projektpraktikum} %Seitenzahl links
\fancyfoot[RO]{Dokumentation zum IT-Projektpraktikum\hspace{3em}\thepage} %Seitenzahl recht

% Titel Linie
\newcommand{\bigrule}{\titlerule[0.5mm]}

% Titel Format
\titleformat{\chapter}[display]
{\bfseries\Huge}
{%
 \vskip-2em
 \titlerule
 \filright
 \Large\chaptertitlename\
 \Large\thechapter
}
{0mm}
{\filright}
[\bigrule]

% Definitionen für Listing
\lstset{ %
language=C++,                % choose the language of the code
numbers=left,                   % where to put the line-numbers
%numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
%showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,                   % adds a frame around the code
tabsize=2,                      % sets default tabsize to 2 spaces
captionpos=t,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
xleftmargin=3.5pt,
xrightmargin=3.5pt,
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
extendedchars=true,captionpos=t , prebreak=\mbox{$\hookleftarrow$}, belowcaptionskip=0.5em,postbreak={},
basicstyle=\ttfamily,       % the size of the fonts that are used for the code
keywordstyle=\color{blue}\bfseries\sffamily,
commentstyle=\color{mygreen}\slshape,
stringstyle=\color{mypurple},
}

\setlength{\parindent}{0pt} % Texteinzug bei neuem Absatz

% ZÃ¤hler fÃ¼r Ausgabe
\newcounter{ausgabe}[chapter]
\renewcommand\theausgabe{\thechapter.\arabic{ausgabe}}

% Programmausgabe, grau hinterlegen
\newcommand{\ausg}[2]{
	\stepcounter{ausgabe}

	\vspace{2mm}
	\begin{minipage}{\textwidth}
	  \colorbox{codegray}{
			\begin{minipage}{0.97\textwidth}
				\textbf{\texttt{#2}}
			\end{minipage}
		}
		\begin{center}
			Ausgabe \theausgabe: #1
		\end{center}
	\end{minipage}
}

% Schreibt 'Code::Blocks'
\newcommand{\cb}{\mbox{Code::Blocks}\xspace}

% Schreibt 'Visual Studio'
\newcommand{\vs}{\mbox{Visual Studio}\xspace}

% TODO - Command
\newcommand{\TODO}[1]{{\color{red}TODO!! #1}}

% code - Command
\newcommand{\code}[1]{
\section{#1}
\lstinputlisting{../#1}
\newpage
}

% Leerseite ohne Seitennummer, nÃ¤chste Seite rechts
\newcommand{\blankpage}{
 \clearpage{\pagestyle{empty}\cleardoublepage}
}



\usepackage{graphicx}
\begin{document}
%----------------------------
\begin{titlepage}
	\begin{flushleft}
		\begin{picture}(0,0)
			\put(0,-2){\includegraphics[height=4em]{KIT_Logo.pdf}}
		\end{picture}
			\put(140,14){\Large Karlsruher Institut für Technologie}
			\put(120,0){\large Institut für Technik der Informationsverarbeitung}
		\begin{picture}(0,0)
			\put(410,-2){\includegraphics[height=4em]{itiv}}
		\end{picture}
	\end{flushleft}

	\begin{center}
		\vspace{7cm}
		\addvspace{1.0cm}
		\Huge {Dokumentation zum Projektpraktikum Informationstechnik}\\
	\end{center}
	\vspace{4.0cm}
	\Large

	\begin{flushleft}
	\begin{tabular}{ll}
		Gruppe:& 064\\
		Gruppenmitglieder:& Benedikt Braunger, Cornelius Richt,\\ & Fabian Schackmar, Lukas Mohrbacher\\
		Tutor:& Florian Brauchle\\
		Abgabetermin:& 18.01.2013\\
		Semester:& WS2011/2012
	\end{tabular}

	\vfill

	KIT - Universität des Landes Baden Württemberg und nationales Forschungszentrum in der Helmholtz-Gemeinschaft
	\end{flushleft}
\end{titlepage}
%----------------------------
\tableofcontents

\newpage
\begin{lstlisting}

\end{lstlisting}
\section{Aufgabenstellung}
Wie Sie in der Einf"uhrung zum Projektpraktikum gelernt haben, weist jedes reale Bauteil eine gewisse zeitliche Verz"ogerung zwischen Ein- und Ausgangssignal auf. F"ur den vorliegenden Fall in Abbildung 2.1 bedeutet dies, dass das Ausgangssignal des 1. Flipflops eine gewisse Zeit braucht, bis es im -Gatter
verarbeitet wurde und am Eingang des 2. Flipflops anliegt.
\\
Abbildung 2.1: Einfaches Schaltwerk
Daraus folgt, dass das zweite Flipflop erst dann getriggert werden darf, wenn das Signal dort sicher
angekommen ist. Es gibt also eine maximale Taktfrequenz, mit der die Schaltung betrieben werden darf.
Diese zu finden ist Aufgabe Ihres Programms. Dazu muss das Programm den l"angsten Signalpfad finden
und dessen Laufzeit berechnen. Die Laufzeit h"angt noch von diversen "Au"seren Einfl"ussen wie Temperatur
und Spannung ab, die Sie ebenfalls ber"ucksichtigen sollen.
\\
 Dieser stellt im Projektpraktikum das Beispiel-
schaltwerk dar, welches untersucht werden soll. 
\begin{figure}[htp]
\centering
\includegraphics[scale=0.40]{3.png}
\caption{}
\label{}
\end{figure}

\subsection{Zeitplanung}
Im ersten Tutorium verschafften wir uns einen groben "Uberblick "uber die Aufgabenstellung und besprachen die Vorgehensweise. Die Umsetzung folgte in den n"achsten Tutorien bis zu den Abschlusstest und der Pr"asentation vor dem Tutor 
\section{das Programm}
\subsection{Men"u}
Das Men"u dient dazu dem Benutzer eine Oberfl"ache zur Verf"ugung zu stellen, mit welcher er das Programm m"oglichst einfach bedienen kann. Dazu geh"ort die Ausgabe der Ergebnisse so wie die M"oglichkeit verschiedene Parameter einzugeben. Zudem werden die einzelnen Instanzen des Programms im Men"u verkn"upft
\begin{figure}[htp]
\centering
\includegraphics[scale=1.00]{1.png}
\caption{}
\label{}
\end{figure}


\subsection{Bibliothek}
\subsubsection{getBibElement(string typ)}
Dieser Methode wird ein string, des Gattertyps (z.B. inv1a), übergegeben.
Sie gibt einen Zeiger auf das entsprechende Element vom Typ GatterTyp zurück.

\subsubsection{dateiAusgabe}
Ausgabe der Datei auf dem Bildschirm, dabei sollen die Zeilen durchnummeriert werden.
Dabei soll, falls die Datei nicht vorhanden ist oder ein Fehler beim Lesen auftritt,
das Programm nicht abstürzen, sondern eine Fehlermeldung ausgeben.

\begin{lstlisting}
void Bibliothek::dateiAusgabe(void)
{
    ifstream f(datei.c_str());

    string buffer;

    int i=0;

    if(f.good())
    {
        while (!f.eof())
        {
            getline(f,buffer);
            cout << i<<": "<<buffer<<endl;
            i++;
        }
    }
    else
    {
        openError();
    }

}
\end{lstlisting}

\subsubsection{dateiAuswrten}
Die Methode dient zum Einlesen und Auswerten der Bibliotheksdatei.
Dabei soll jeder in der Datei beschriebene Gattertyp in einem Element vom Typ
GatterTyp im Vektor bibElemente gespeichert werden. Die Reihenfolge ist
dabei nicht wichtig. Das Flipflop kann dabei am Namen erkannt werden, welcher als bekannt vorausgesetzt wird.
Das Flipflop wird in einem Element vom Typ Flipflop im Vektor bibElemente gespeichert.
\\
Zum Erstellen der FlipFlops einer Kindklasse von GatterTyp haben wir einen zus"atzlichen Vector benutzt und diesen nach Erfolgreichem Anlegen der Bauteile in den Gattertyp-Vector gecastet
\\
Dei Datei wird zeilenweise durchgegangen um die Elemente anzulegen. Ein neues Element beginnt an einer [ Klammer und endet an einer leeren Zeile.
\begin{lstlisting}
void Bibliothek::dateiAuswerten(void)
{
    ifstream f(datei.c_str());

    string buffer;
    while (!f.eof())
    {
        getline(f,buffer);
        //"\r" entfernen
        buffer.erase(buffer.size()-1);

        //von [[Bausteine]] bis Leerzeile einlesen
        if(buffer.find("[[Bausteine]]")==0)
        {

            while (!f.eof())
            {
                getline(f,buffer);

                if(buffer=="\r")
                {

                    debug_msg("Blockende gefunden");
                    break;
                }

                //"\r" entfernen
                buffer.erase(buffer.size()-1);



                /*if(buffer =="dff")
                {
                    Flipflop* dummy = (new Flipflop());

                    dummy->setName(buffer);

                    bibElemente.push_back(*dummy);

                    debug_msg( "ff angelegt: "<<buffer);

                }
                else
                {
                    GatterTyp* dummy= new GatterTyp();
                    dummy->setName(buffer);

                    bibElemente.push_back(*dummy);
                    debug_msg( "gt angelegt: "<<buffer);

                }*/




            }
        }

        else if(buffer.find("[")==0)
        {
            //Kalmmern [ ] entfernen
            string name = buffer.substr(1,buffer.size()-2);


                //FF anlegen
                if(name=="dff")
                {
                    Flipflop *ff = new Flipflop();
                    ff->setName(name);

                    debug_msg(name <<"als FF anlegen");


                    while (!f.eof())
                    {
                        getline(f,buffer);

                        //Abbruch falls Absatz zu Ende
                        if(buffer=="\r")
                        {

                            //FF zu bibElemente hinzfügen
                             bibElemente.push_back((ff));




                            debug_msg("Ende von: "<<name<<" gefunden");
                            break;
                        }
                        //"\r" entfernen
                        buffer.erase(buffer.size()-1);



                        ///*allgemeine Attribute
                        if(buffer.find("ei:")==0)
                        {
                            ff->setEingaenge(atoi(buffer.substr(3).c_str()));
                            debug_msg( "ei init "<<ff->getEingaenge());
                        }

                        else if(buffer.find("cl:")==0)
                        {
                            ff->setLastKapazitaet(atoi(buffer.substr(3).c_str()));
                            debug_msg("cl init "<<ff->getLastKapazitaet());
                        }

                        else if(buffer.find("kl:")==0)
                        {
                            ff->setLastFaktor(atoi(buffer.substr(3).c_str()));
                            debug_msg("kl init "<<ff->getLastFaktor());
                        }

                        else if(buffer.find("tpd0:")==0)
                        {
                            ff->setGrundLaufzeit(atof(buffer.substr(5).c_str()));
                            debug_msg("tpd0 init "<<ff->getGrundLaufzeit());
                        }


                        ///*Flipflop Attribute
                        else if(buffer.find("tsetup:")==0)
                        {
                            ff->setSetupTime(atoi(buffer.substr(7).c_str()));
                            debug_msg("ff testup init: "<<ff->getSetupTime());

                        }
                        else if(buffer.find("ed:")==0)
                        {
                            ff->setEingaenge(atoi(buffer.substr(3).c_str()));
                            debug_msg("ff ed init: "<<ff->getEingaenge());

                        }
                        else if(buffer.find("thold:")==0)
                        {
                            ff->setHoldTime(atoi(buffer.substr(6).c_str()));
                            debug_msg("ff thold init: "<<ff->getHoldTime());

                        }
                        else if(buffer.find("cd:")==0)
                        {
                            ff->setLastKapazitaet(atoi(buffer.substr(3).c_str()));
                            debug_msg("ff cd init: "<<ff->getLastKapazitaet());

                        }
                        else if(buffer.find("tpdt:")==0)
                        {
                            ff->setGrundLaufzeit(atof(buffer.substr(5).c_str()));
                            debug_msg("ff tpdt init: "<<ff->getGrundLaufzeit());

                        }
                        else if(buffer.find("kl:")==0)
                        {
                            ff->setLastFaktor(atoi(buffer.substr(3).c_str()));
                            debug_msg("ff kl init: "<<ff->getLastFaktor());

                        }
                        else if(buffer.find("ct:")==0)
                        {
                            ff->setLastKapazitaetClock(atoi(buffer.substr(3).c_str()));
                            debug_msg("ff ct init: "<<ff->getLastKapazitaetClock());

                        }

                        else
                        {
                            if(buffer.find("#endf")!=0){
                                //Falls Attribut nicht gefunden
                                readError();
                                debug_msg(buffer<<" nicht gefunden");
                            }
                            else { bibElemente.push_back((ff));break;}
                        }

                    }


                }

                else{

                    GatterTyp *gt = new GatterTyp();

                    debug_msg(name <<"als GT anlegen");
                    gt->setName(name);



                                        while (!f.eof())
                    {
                        getline(f,buffer);

                        //Abbruch falls Absatz zu Ende
                        if(buffer=="\r")
                        {

                            //GT zu bibElemente hinzfügen
                            bibElemente.push_back(gt);





                            debug_msg("Ende von: "<<name<<" gefunden");
                            break;
                        }
                        //"\r" entfernen
                        buffer.erase(buffer.size()-1);



                        ///*allgemeine Attribute
                        if(buffer.find("ei:")==0)
                        {
                            gt->setEingaenge(atoi(buffer.substr(3).c_str()));
                            debug_msg( "ei init "<<gt->getEingaenge());
                        }

                        else if(buffer.find("cl:")==0)
                        {
                            gt->setLastKapazitaet(atoi(buffer.substr(3).c_str()));
                            debug_msg("cl init "<<gt->getLastKapazitaet());
                        }

                        else if(buffer.find("kl:")==0)
                        {
                            gt->setLastFaktor(atoi(buffer.substr(3).c_str()));
                            debug_msg("kl init "<<gt->getLastFaktor());
                        }

                        else if(buffer.find("tpd0:")==0)
                        {
                            gt->setGrundLaufzeit(atof(buffer.substr(5).c_str()));
                            debug_msg("tpd0 init "<<gt->getGrundLaufzeit());
                        }


                        else
                        {
                            if(buffer.find("#endf")!=0){
                                //Falls Attribut nicht gefunden
                                readError();
                                debug_msg(buffer<<" nicht gefunden");
                            }
                            else break;
                        }

                    }


                }

        }
    }



    for(int h=0;h<bibElemente.size();h++){
        debug_msg( bibElemente[h]->getName());
    }






}

\end{lstlisting}


\subsubsection{Fehlerausgabe}
Die Fehlerausgabe findet in folgenden Methoden statt. Dies erm"oglicht eine bessere Fehlerbehandlung, zB die Ausgabe von verschiedenen Sprachen.\\ C++ bietet allerdings noch weit aus bessere M"oglichkeiten Fehler richtig abzufangen
\begin{lstlisting}
/**Ausgabe einer Fehlermeldung beim ändern einer Datei. */
void Bibliothek::openError(void)
{
    cerr <<"OPEN ERROR"<<endl;

}
/**Ausgabe einer Fehlermeldung beim Lesen einer Datei.
*/
void Bibliothek::readError(void)
{
    cerr <<"READ ERROR"<<endl;

}
\end{lstlisting}

\subsection{Gattertyp und Flipflop}
Die Klasse Flipflop ist eine Erweiterung der Klasse Gattertyp beide stellen Bauteile da, welche im Schaltwerk verwedet werden. Sie werden in der Bibliothek initialisert.

\subsection{Grapherzeuger}
Der Grapherzeuger legt eine verkette Liste aus den Schaltwerkelementen an und erzeugt somit die Schaltung aus den einzelnen Bauteilen. Zudem wird die Schaltung auf offene Eing"ange gepr"uft. Mit der Methode run wird "uberpr"uft ob die Eing"ange der Schaltung mit den vorhanden Eing"angen "ubereinstimmt, ist dies nicht der Fall wird ein entsprechender Fehler ausgegeben und die Erzeugng des Graphen abgebrochen.
\begin{lstlisting}
startElement = NULL;///Initialisierung
    endElement = NULL;
    signale = NULL;
    anzahlSignale = 0;
    gAnzahl = 0;

    short eingaenge = 0;
    short ausgaenge = 0;

    ListenElement* tmpElement = NULL;
    anzahlSignale = signallist.getAnzahlSignale();

/// geht Signalliste durch
    for (int i = 0; i < anzahlSignale; i++)
    {
        Signal tmpSignal = *signallist.getSignal( i );

        if ((tmpSignal.getSignalTyp() == eingang) )         /// prueft ob Eingang
        {
            debug_msg("INFO: eingang gefunden");
            eingaenge++;
        }
        else if (tmpSignal.getSignalTyp() == clk)         /// prueft ob Takt
        {
            debug_msg("INFO: clock gefunden");
        }
        else if ((tmpSignal.getSignalTyp() == intern) or (tmpSignal.getSignalTyp() == ausgang))   /// wenn intern oder ausgangs-signal hat das signal eine quelle,
        {
            /// die man in Schaltwerke ueberfuehren kann
            if ( tmpSignal.getQuelle() != "" )          /// zum abfangen von unbenutzten Signalen
            {
                GatterTyp* tmpGatter = bibliothek->getBibElement(tmpSignal.getQuellenTyp());  // kann man sich theoretisch auch sparen und alle tmpGatter durch bibliothek->getBibElement(tmpSignal.getQuellenTyp()) ersetzen

                ListenElement* newListenElement = new ListenElement();
                SchaltwerkElement* newSchaltwerkElement = new SchaltwerkElement( tmpGatter );

                /// Schaltwerk uebernimmt Daten des Signals
                newSchaltwerkElement->setName(tmpSignal.getQuelle());
                newSchaltwerkElement->setAnzahlNachfolger(tmpSignal.getAnzahlZiele());
                newSchaltwerkElement->setLaufzeitEinzelgatter( tmpGatter->getGrundLaufzeit() );
                newSchaltwerkElement->setAnzahlEingangssignale( tmpGatter->getEingaenge());

                /// pruefen ob Ausgang
                if ( tmpSignal.getSignalTyp() == ausgang )
                {
                    newSchaltwerkElement->setIsAusgangsElement(true);
                    debug_msg("INFO: ausgang gefunden");
                    ausgaenge++;
                }

                /// verknuepfen von Schaltwerkselement mit Listenelement
                newListenElement->setSchaltwerkElement( newSchaltwerkElement );
                gAnzahl++;
                debug_msg("INFO: "<<gAnzahl<<". ListenElement angelegt vom Typ "<< tmpSignal.getQuellenTyp()<<" !");


                /// baut die Liste auf
                if ( startElement == NULL )  /// ist nur NULL,wenn noch kein Element der Liste existiert
                {
                    endElement = newListenElement;
                    startElement = newListenElement;

                }
                else
                {
                    tmpElement->setNextElement( newListenElement );
                    endElement = newListenElement;
                }
                tmpElement = newListenElement;

            }
            else   // von leerer Quelle Abfrage, um ungenutzte Signake zu erkennen
            {
                cout << "Fehler! Unbenutztes Signal gefunden" << endl;
                cin.ignore();
                cin.get();
            }
        }

        else            // von Signaltypabfrage
        {
            cout << "Fehler! Unbekannter Signaltyp" << endl;
            cin.ignore();
            cin.get();
        }
    }
    /// eingang finden
    for (int z = 0; z < signallist.getAnzahlSignale(); z++)                /// geht die Sigalliste durch
    {
        if ( signallist.getSignal(z)->getSignalTyp() == eingang)            /// vergleicht mit Signaltypen, ob "eingang" der Signaltyp ist
        {
            debug_msg( "INFO: Dieses Eingangssignal hat "<<signallist.getSignal(z)->getAnzahlZiele()<< " Ziel(e)");
            for ( int y = 0; y < signallist.getSignal(z)->getAnzahlZiele(); y++)               /// durchlaeuft alle ziele dieses signals
            {
                string eingangsGatter = signallist.getSignal(z)->getZiel( y );
                for (ListenElement* ptr = startElement; ptr != NULL; ptr = ptr->getNextElement())   /// und gleicht die ziele mit den schaltwerksnamen in dem
                {
                    if ( ptr->getSchaltwerkElement()->getName() == eingangsGatter )                 /// jeweiligen listenelement ab
                    {
                        ptr->getSchaltwerkElement()->setIsEingangsElement(true);
                        debug_msg( "INFO: "<< ptr->getSchaltwerkElement()->getName() <<" ist Eingang");
                    }
                }
            }
        }
    }

    /// prueft, ob es unbeschaltete Eingaenge gibt
    short tmpZaehler ;
    for (ListenElement* ptr = startElement; ptr != NULL; ptr = ptr->getNextElement())   /// durchlaeuft die Listenelemente
    {
        tmpZaehler = 0;

        debug_msg("INFO:-----");

        for (int z = 0; z < signallist.getAnzahlSignale(); z++)         ///danach die Signalliste
        {
            for (int r = 0; r < signallist.getSignal(z)->getAnzahlZiele(); r++)     /// und die Ziele eines jeden Signals
            {

                /// prueft, ob das Signalziel mit dem SchaltwerkElementsnamen uebereinstimmt und erhoeht den Eingangszaehler bei Erfolg um 1
                if ( signallist.getSignal(z)->getZiel(r) == ptr->getSchaltwerkElement()->getName())
                {
                    tmpZaehler += 1;

                    debug_msg("INFO: "<< tmpZaehler <<". Eingang von "<< ptr->getSchaltwerkElement()->getName() <<" gefunden");
                }
            }
        }
        /// falls dff mit clk, hat die Bib einen Eingang zu wenig, wird hier korrigiert
        if (ptr->getSchaltwerkElement()->getTyp()->getName()=="dff")  // weil der clock eingang nicht mit eingelesen wird.. sollte man vlt noch aendern
        {
            tmpZaehler -= 1;
        }
        /// check, ob Schaltwerk und Bib fuer das jeweilige Element dieselbe Anzahl Eingaenge verzeichnet haben
        if (ptr->getSchaltwerkElement()->getTyp()->getEingaenge() != tmpZaehler)
        {
            cout << "Fehler!\nAnzahl Eingaenge laut Bibliothek: \t"<<ptr->getSchaltwerkElement()->getTyp()->getEingaenge()<<endl
            <<"Anzahl Eingaenge laut Schaltwerk: \t"<<tmpZaehler << endl;
            cin.ignore();
            cin.clear();
            cin.get();
        }
    }

}


void GraphErzeuger::graphErzeugen(SignalListeErzeuger signallist)
{
    /// durchlaeuft die Liste der durch ListenElemente verknuepften Schaltwerke
    for (ListenElement* ptr = startElement; ptr != NULL; ptr = ptr->getNextElement())
    {
        ListenElement* tmpListenElement = ptr;
        SchaltwerkElement* tmpSWE = tmpListenElement->getSchaltwerkElement();

        /// prueft ob ein Schaltwerk maximal 5 Nachfolger besitzt
        if ( tmpSWE->getAnzahlNachfolger() <= 5)
        {

            /// durchlaeuft die Signalliste auf der Suche nach gleichnamigen Quellen der Signale und Schaltwerksnamen
            for (int i = 0; i < signallist.getAnzahlSignale(); i++)
            {

                Signal tmpSignal = *signallist.getSignal( i );

                if ( tmpSignal.getQuelle() == tmpSWE->getName())
                {

                    /// bei Treffer wird wieder die Signalliste durchlaufen auf der Suche nach den Zielen des gleichnamigen Signals
                    for ( int j = 0; j < tmpSignal.getAnzahlZiele(); j++)
                    {
                        string folgeGatter = tmpSignal.getZiel( j );

                        /// sucht zu den Zielen des Signals das entsprechende Schaltwerk aus den ListenElementen
                        for (ListenElement* ptr2 = startElement; ptr2 != NULL; ptr2 = ptr2->getNextElement())
                        {
                            ListenElement* tmpListenElement2 = ptr2;
                            if ( tmpListenElement2->getSchaltwerkElement()->getName() == folgeGatter )
                            {
                                tmpListenElement->getSchaltwerkElement()->nachfolgerHinzufuegen( tmpListenElement2->getSchaltwerkElement(), j );
                                debug_msg( "INFO: "<< tmpListenElement2->getSchaltwerkElement()->getName() << " ist Nachfolger von " << tmpListenElement->getSchaltwerkElement()->getName());
                            }
                        }
                    }

                }

            }

        }
        else          // von Anzahlnachfolger if-Abfrage
        {
            cout << "Fehler: Mehr als 5 Nachfolgegatter bei "<< tmpSWE->getName() << endl;
        }

    }

}

void GraphErzeuger::listenAusgabe ( )         /// gibt die Listenelemente mit Gatternamen und ihre NachfolgeGatter aus
{

    for ( ListenElement* ptr = startElement; ptr != NULL; ptr = ptr->getNextElement())  /// geht die ListenElemente durch
    {

        cout << "-----------\n"<<endl
        <<"Gattername:  \t\t" <<  ptr->getSchaltwerkElement()->getName() <<endl                  /// Gattername
        <<"Gattertyp:  \t\t" << ptr->getSchaltwerkElement()->getTyp()->getName() <<endl;         /// GatterTyp

        /// evtle zusaetzliche Ausgaben wie "Eingang", "Ausgang", "LaufzeitEinzelGatter", fuer FlipFlops noch andere Attribute
        if ( ptr->getSchaltwerkElement()->getIsEingangsElement() == true)         // kann man sich mal noch ueberlegen in die Ausgabe mit aufzunehmen
        {
            cout <<"Schaltungseingangselement"<<endl;
        }
        if ( ptr->getSchaltwerkElement()->getIsAusgangsElement() == true)
        {
            cout<<"Schaltungsausgangselement"<< endl;
        }
        cout<<"Laufzeit Einzelgatter: \t"<< ptr->getSchaltwerkElement()->getLaufzeitEinzelgatter() <<endl;

            cout << "Is Flipflop: \t\t"<< (( Flipflop*) (ptr->getSchaltwerkElement()->getTyp()) )->getIsFlipflop()<<endl;

        if (ptr->getSchaltwerkElement()->getTyp()->getName()== "dff")
        {
           cout << "Setup-Time: \t\t" << (( Flipflop*) (ptr->getSchaltwerkElement()->getTyp()) )->getSetupTime() << endl
            << "Hold-Time \t\t" << (( Flipflop*) (ptr->getSchaltwerkElement()->getTyp()) )->getHoldTime()<<endl
            << "Lastkapazitaet: \t"<< (( Flipflop*) (ptr->getSchaltwerkElement()->getTyp()) )->getLastKapazitaetClock()<<endl;
        }

        cout<<"Anzahl Eingangssignale: "<< ptr->getSchaltwerkElement()->getAnzahlEingangssignale() <<endl;        // Ende Fakultative Ausgabe

        /// Ausgabe der Anzahl der Folgegatter und dann der Gatter mit ihrem Namen
        if (ptr->getSchaltwerkElement()->getAnzahlNachfolger()==1){
            cout<<"--->Das Gatter hat "<< ptr->getSchaltwerkElement()->getAnzahlNachfolger()<<" Ziel" <<endl;  /// Einzahl
        }else if(ptr->getSchaltwerkElement()->getAnzahlNachfolger()==0){
            cout<<"--->Das Gatter hat keine Ziele" <<endl;                                                     /// Keine
        }else{
            cout<<"--->Das Gatter hat "<< ptr->getSchaltwerkElement()->getAnzahlNachfolger()<<" Ziele" <<endl; /// Mehrzahl
        }

        if (ptr->getSchaltwerkElement()->getAnzahlNachfolger()!=0) /// falls Nachfolger existieren
        {

            string ausgabe = " ";
            for ( int s = 0; s < ptr->getSchaltwerkElement()->getAnzahlNachfolger() ; s++)  /// werden alle Nachfolgernamen in einen Ausgabe string geschrieben
            {

                ausgabe = ausgabe  + ptr->getSchaltwerkElement()->getNachfolger(s)->getName() + " ";
            }
            cout << "Angeschlossene Gatter:\t"<<ausgabe <<endl;
        }
        else /*if (ptr->getSchaltwerkElement()->getAnzahlNachfolger()==0)*/ /// falls keine Nachfolger existieren
        {
            cout << ptr->getSchaltwerkElement()->getName() << " hat keine Folgegatter"<<endl;
        }

    }
}

\end{lstlisting}

\subsection{SignallisteErzeuger}
SignallisteErzeuger lie"st die gegebene Datei "ahnlich wie in der Biblothek ein und spechert diese in einem Vector

\begin{lstlisting}
#include "SignalListeErzeuger.h"

/**Konstruktor
Setzt alle Variablen auf 0
**/
SignalListeErzeuger::SignalListeErzeuger()
{
    //ctor
    anzahlSignale = 0;
    frequenz = 0;
    datei="";
    /*setDatei(file);
    readFile();*/ ///Manuell im Menü aufrufen
}

/**Destruktor
**/
SignalListeErzeuger::~SignalListeErzeuger()
{
    //dtor
}

/**dateiAusgabe
öffnet die Datei die in der 'datei' Variable der Klasse gespeichert ist und gibt die aus
**/
void SignalListeErzeuger::dateiAusgabe(void)
{
    ifstream f(datei.c_str());

    string buffer;

    int i=0;

    if(f.good())
    {
        while (!f.eof())
        {
            getline(f,buffer);
            cout << i<<": "<<buffer << endl;
            i++;
        }
    }
    else
    {
        cout << "ERR: Can not read file!";
    }

}
/** Gibt Signal aus dem 'signale' Vektor an der im Parameter spezifizierten Stelle zurück
**/
Signal* SignalListeErzeuger::getSignal(int i) {
    return &signale.at(i) ;
}

/**Liest die 'datei' aus und beginnt mit der Auswertung
**/
int SignalListeErzeuger::readFile() {
    signale.clear();                              ///Vektor 'signale' wird geleert
    string line;
    ifstream listfile(getDatei().data());           ///öffne Dateistream
    Signal* bufferobj = new Signal;
    signale.push_back( *bufferobj );                ///Reserviere leeres Objekt für die CLOCK
    if (listfile.is_open()) {
        //debug_msg( "INFO: file is open" );
        while (!listfile.eof()) {
            getline(listfile,line);                         ///liest Zeile für Zeile aus
            if (((line.substr(0,2)) == "//") or (line == "\r") or (line == "")) {
                debug_msg( "INFO: drop, comment or empty line" );
            }else if ((line.substr(0,12)) == "ARCHITECTURE") {                              ///Wenn Kommentar, leere Zeile oder Schwachsinn drin steht, passiert gar nichts
                debug_msg( "INFO: drop, ARCHITECTURE shit" );
            }else if ((line.substr(0,6)) == "ENTITY") {
                while (1) {
                    getline(listfile,line);
                    if ((line.substr(0,2)) == "//") {
                        debug_msg( "INFO: drop, comment or empty line" );
                    }else if ((line.substr(0,5)) == "INPUT") {
                        debug_msg( "INFO: Found INPUT line!" );
                        readSignalLine(eingang,5,line);
                    }else if ((line.substr(0,6)) == "OUTPUT") {
                        debug_msg( "INFO: Found OUTPUT line!" );
                        readSignalLine(ausgang,6,line);
                    }else if ((line.substr(0,7)) == "SIGNALS") {
                        debug_msg( "INFO: Found SIGNALS line!" );
                        readSignalLine(intern,7,line);
                    }else if ((line.substr(0,5)) == "CLOCK") {
                        debug_msg( "INFO: Found CLOCK line!" );
                        string hr_frequency = line.substr(11,(line.length()-11));                    ///Schneide Frequenz aus
                        frequenz = atoi(hr_frequency.data());                                        ///Lese Frequenzzahl
                        if (hr_frequency.substr(hr_frequency.size()-5,1)=="M") {                                                ///Multipliziere frequenz
                            frequenz = frequenz * 1000000;
                        } else if (hr_frequency.substr(hr_frequency.size()-5,1)=="k") {
                            frequenz = frequenz * 1000;
                        }
                        bufferobj->setSignalTyp(clk);
                        signale.at(0) = *bufferobj;
                        debug_msg( "INFO: Set clk to:  " << frequenz );
                    }else if (line == "\r" or (line == "")){
                        debug_msg( "INFO: Found empty line, leave ENTITY area!" );
                        break;
                    }else {
                        debug_msg( "ERR: Error reading line" );
                        break;
                    }
                }
            }else if ((line.substr(0,5)) == "BEGIN") {
                while (1) {
                    getline(listfile,line);
                    if ((line.substr(0,2)) == "//") {
                        debug_msg( "comment" );
                    }else if ((line.substr(0,1)) == "g") {
                        debug_msg( "INFO: Found GATE line!" );
                        if (readGateLine(line) == 1 ) {                                          ///Wenn Kurzschluss bereits vorhanden
                            cout << "ERR: Short curcuit"  << endl;
                            cin.get();
                            return 21;
                        }
                    }else if ((line.substr(0,6)) == "END") {
                        debug_msg( "INFO: Found END line!" );
                            signalTypen tmpsig;
                            tmpsig = signale.at(0).getSignalTyp();
                            debug_msg( "DEBUG "<< tmpsig );
                            setAnzahlSignale(signale.size());                                       ///AnzahlSignale auf die Grösse des Vektor setzen
                            debug_msg( "DEBUG: AnzahlSignale: " << getAnzahlSignale() );
                        return 0;
                    }else {
                        debug_msg( "ERR: Error reading line" );
                        break;
                    }
                }
            } else {//------------------------------------------else
                debug_msg( "ERR: Error reading headline" );
                break;
            }
        }
    } else {
        cout << "ERR: Error opening file!";
        cin.get();
        return 1;
    }
    return 0;
}

int SignalListeErzeuger::readSignalLine(signalTypen typ, int lengthBegin, string tmpLine) {
    string tmpSignal;
    stringstream tmpStream(tmpLine.substr(lengthBegin+1,(tmpLine.length()-(lengthBegin+2+linuxzusatz))));       ///Erstellt Stream und schneidet Anfang und Ende ab
    while (getline(tmpStream,tmpSignal,',')) {                                                      ///Trennt nach Komma
        debug_msg( "INFO: Aktuelles Signal: " << tmpSignal );
        unsigned int tmpSignalNo = atoi(tmpSignal.substr(1,3).c_str());                                       ///Lese Nummer von aktuellem Signal
        debug_msg( "DEBUG: tmpSignalNo: " << tmpSignalNo );
        Signal* nullObj = new Signal;                                                                  ///Erzeuge leeres Objekt
        while (signale.size() <= tmpSignalNo) {                                              ///Solange der Vektor kleiner ist als aktuelle Signalnummer
            signale.push_back( *nullObj );                                                             ///Vergrössere Vektor
        }
        signale.at(tmpSignalNo).setSignalTyp(typ);                                          ///Schreibe Typ an Stelle der akt. Signalnummer in Vektor
    }
}

int SignalListeErzeuger::readGateLine(string tmpLine) {
    string gateNo, gatetype, tmpSignal;
    gateNo = tmpLine.substr(0,4);                                       ///Schneide Gatenummer heraus
    gatetype = tmpLine.substr(5,tmpLine.find("(")-5);                   ///Schneide Gatetyp abhängig von der Länge heraus
    tmpLine = tmpLine.substr(tmpLine.find("(")+1,tmpLine.size()-tmpLine.find("(")-3-linuxzusatz);           ///Schneide Signale heraus
    string tmpOut = (tmpLine.substr(tmpLine.size()-2-linuxzusatz,3));                                       ///Schneide Ausgang heraus
    if (signale.at(atoi(tmpOut.c_str())).getQuelle().empty()) {                                     ///Prüfe auf Kurzschluss
        signale.at(atoi(tmpOut.c_str())).setQuelle(gateNo);                                         ///Setze Quelle für Ausgangssignal
    }
    else {
        return 1;
    }
    signale.at(atoi(tmpOut.c_str())).setQuellentyp(gatetype);                                         ///Setze Quelletyp für Ausgangssignal
    tmpLine = tmpLine.erase(tmpLine.size()-5,5);                                                      ///Schneide Ausgang ab
    stringstream tmpStream(tmpLine);                                                            ///Erstelle String stream
    while (getline(tmpStream,tmpSignal,',')) {                                                  ///Trenne nach Komma
        debug_msg( "tmpSignal: " << tmpSignal );
        debug_msg( "DEBUG: Vect: " << tmpSignal.substr(1,3) );
        if (tmpSignal == "clk") {
            signale.at(0).zielHinzufuegen(gateNo);
        }
        else {
            signale.at(atoi((tmpSignal.substr(1,3)).c_str())).zielHinzufuegen(gateNo);               ///Füge Ziele zu aktuellem Signal hinzu
        }
    }
    return 0;
}

long SignalListeErzeuger::getFrequenz(){
    return frequenz;
}
string SignalListeErzeuger::getDatei() {
    return datei;
}
short SignalListeErzeuger::getAnzahlSignale(){
    return anzahlSignale;
}
void SignalListeErzeuger::setFrequenz(long freq){
    frequenz = freq;
}
void SignalListeErzeuger::setDatei(string file){
    datei = file;
}
void SignalListeErzeuger::setAnzahlSignale(short nSignals){
    anzahlSignale = nSignals;
}

\end{lstlisting}

\subsection{signal}
Ist eine Klasse um Signalattribute zu speichern
\subsection{Faktoren}
Speichert Attributte und berechnet Faktoren die sich auf die Laufzeit auswirken, wie zB Temperatur und Herstellungsprozesse. Zudem ist die Klasse f"ur die Interpolation verantwortlich
\subsection{LaufzeitAnalysator}
\subsubsection{berechne LaufzeitEinzelgatter}
In dieser Methode wird die Laufzeit der einzelnen Gatter abhängig von äu"seren Faktoren berechnet

\subsubsection{Zyklensuchse}
Die Zyklensuche pr"uft die Schaltung auf einen eventuell vorhandenen Zyklus, damit die Laufzeitanalyse darauf reagieren kann


\subsubsection{LaufzeitAnalysator DFS Visit}
Die Tiefensuche durchsucht die einzelnen "Aste des Baumes nach evtuellen Zyklen und berechnet den l"angsten "Ubergangspfad sowie Ausgangspfad


\subsubsection{maxFrequenz}
Im Folgenden wird die maximale Frequenz berechnet, mit welcher die Schaltung betrieben werden kann und gepr"uft ob die vorgesehene Frequenz die maximale Frequenz nicht "uberschreitet

\section{Abschlussest}
Nach der Fertigstellung des Programms testeten wir es mit verschiedenen Fehlerhaften Dateien um eventuelle Kurzschl"uesse oder Zyklen im Schaltnetz zu finden und die richtige Fehlermeldung ausgeben zu können. Zudem verglichen wir die ausgebenen Ergebnisse und pr"uften sie auf Richtigkeit

Wir testeten folgende Dateien, welche alle zur richtigen Fehlerausgabe f"urten 
	\begin{itemize}
	\item test Kurzschluss.txt 
	\item test UnbenutztesSignal.txt 
	\item test zyklus.txt
	\item test OffenerEingang.txt  
	\item test Zyklus1.txt           
	\item Test Schaltnetze.pdf     
	\item test Zyklus2.txt           

	\end{itemize}

\begin{figure}[htp]
\centering
\includegraphics[scale=0.50]{2.png}
\caption{}
\label{}
\end{figure}
\newpage
\section{Materialien}
 \subsection{Software}
 	 Codeblocks Linux ( mit cross compatibility zu Windows)
 	 Wir entwickelten unser Programm under Linux und passten es entsprechend an, damit es auch unter Windows ausf"uhrbar ist
 \subsection{Hilfsmittel}
 	Als Hilfsmittel benutzen wir das C++ Kompendium

\newpage
\section{Quellcode}
\include{05-code}

\end{document}
